<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>SongMatch</title>
  <style>
    :root { color-scheme: dark; }
    * { box-sizing: border-box; }
    body { font-family: system-ui, Arial, sans-serif; background:#0b0f14; color:#fff; margin:0; }

    /* Topbar */
    .topbar {
      position:sticky; top:0; z-index:40; backdrop-filter: blur(6px);
      background:rgba(10,14,20,.7); border-bottom:1px solid rgba(255,255,255,.06);
      display:flex; align-items:center; gap:8px; padding:10px 12px;
    }
    .brand { font-weight:800; letter-spacing:.3px; }
    .spacer { flex:1; }
    .tb-btn { background:#1f2a3a; color:#fff; border:none; border-radius:10px; padding:8px 12px; cursor:pointer; }

    /* Gates & Auth */
    .gate, .auth { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:#000; z-index:9999; }
    .card { background:#121822; padding:24px; border-radius:14px; width:min(420px,92vw); }
    .card h1, .card h2 { margin:0 0 8px 0; }
    .field { display:flex; flex-direction:column; gap:6px; margin:10px 0; }
    .field input { padding:12px 14px; border-radius:10px; border:none; background:#0f1520; color:#fff; }
    .btn { padding:12px 14px; border-radius:10px; border:none; background:#7aa2ff; color:#fff; font-weight:700; cursor:pointer; }
    .muted { opacity:.75; font-size:14px; }
    html:not(.gate-ok) .app { display:none; }
    html.gate-ok .gate { display:none; }
    html.auth-ok .auth { display:none; }

    /* App shell */
    .wrap { max-width:820px; margin:0 auto; padding:16px; }
    .panel { background:#121822; margin:20px 0; padding:20px; border-radius:14px; }

    /* Swipe card */
    .swipe-wrap { position:relative; height:460px; display:flex; align-items:center; justify-content:center; touch-action:pan-y; }
    .swipe-card {
      position:absolute; width:min(360px,92vw); height:420px; border-radius:16px; overflow:hidden;
      box-shadow:0 10px 30px rgba(0,0,0,.35); background:#0f1520;
      transition: transform .25s ease, opacity .25s ease; touch-action: none; animation: popin .25s ease;
      display:flex; flex-direction:column; justify-content:space-between;
    }
    @keyframes popin { from{ transform:scale(.96); opacity:.0 } to{ transform:scale(1); opacity:1 } }

    .cover { position:relative; height:78%; display:flex; align-items:center; justify-content:center; background:#0b0f14; }
    .cover img { max-width:100%; max-height:100%; display:block; }
    .playbtn {
      position:absolute; bottom:12px; left:50%; transform:translateX(-50%);
      background:#1f2a3a; border:none; color:#fff; border-radius:999px; padding:10px 16px; cursor:pointer; font-weight:800;
    }
    .meta { height:22%; padding:10px 12px; display:flex; justify-content:space-between; align-items:center; gap:10px; }
    .title { font-weight:700; font-size:14px; }
    .artist { font-size:12px; opacity:.8; }
    .open { background:#1f2a3a; border:none; color:#fff; border-radius:10px; padding:8px 12px; cursor:pointer; }

    .badge { position:absolute; top:12px; padding:6px 10px; border-radius:8px; font-weight:800; letter-spacing:.5px; opacity:0; transition:opacity .12s ease; pointer-events:none; }
    .badge.like { left:12px; background:rgba(46,204,113,.9); }
    .badge.nope { right:12px; background:rgba(231,76,60,.9); }

    .row { display:flex; gap:14px; align-items:center; justify-content:center; flex-wrap:wrap; margin-top:12px; }
    .round { width:58px; height:58px; border-radius:50%; display:inline-flex; align-items:center; justify-content:center; border:none; cursor:pointer; font-size:22px; }
    .round.like { background:#2ecc71; }
    .round.nope { background:#e74c3c; }
    .round.undo { background:#4b5563; }
    .round.skip { background:#374151; }
    .round:disabled { opacity:.6; cursor:not-allowed; }

    .playlist { display:grid; gap:10px; }
    iframe.embed-small { width:100%; height:80px; border-radius:10px; }
    .tiny { font-size:12px; opacity:.7; }
  </style>
</head>
<body>
  <!-- Topbar -->
  <div class="topbar">
    <div class="brand">SongMatch</div>
    <div class="spacer"></div>
    <button id="inviteBtn" class="tb-btn">üîó Invite kopieren</button>
    <button id="logoutBtn" class="tb-btn">üö™ Abmelden</button>
  </div>

  <!-- Zugangscode -->
  <div class="gate">
    <div class="card">
      <h1>Zugang</h1>
      <p class="muted">Bitte Code eingeben:</p>
      <div class="field"><input id="gateCode" type="password" placeholder="Code (z. B. 1235)" /></div>
      <button id="gateBtn" class="btn">Weiter</button>
    </div>
  </div>

  <!-- Account auth -->
  <div class="auth">
    <div class="card">
      <h2 id="authTitle">Anmelden</h2>
      <div class="field"><input id="username" placeholder="Username (ohne E-Mail)" /></div>
      <div class="field"><input id="password" type="password" placeholder="Passwort" /></div>
      <button id="loginBtn" class="btn">Anmelden</button>
      <div class="muted" style="margin-top:10px">
        <span id="authSwitchText">Noch kein Account?</span>
        <button id="authSwitch" class="btn" style="background:transparent;border:1px solid #7aa2ff;">Account erstellen</button>
      </div>
      <p id="authMsg" class="muted" style="margin-top:6px"></p>
    </div>
  </div>

  <!-- App -->
  <div class="app">
    <div class="wrap">
      <div class="panel">
        <div style="display:flex;justify-content:space-between;align-items:center;gap:8px;">
          <h2 style="margin:0">N√§chster Song</h2>
          <div class="tiny" id="progressInfo">‚Äì</div>
        </div>

        <div id="songArea" class="muted" style="min-height:460px">l√§dt Songs ‚Ä¶</div>

        <div class="row">
          <button id="undoBtn" class="round undo" title="Undo" disabled>‚Ü©Ô∏è</button>
          <button id="nopeBtn" class="round nope" title="Nope" disabled>‚úñÔ∏è</button>
          <button id="likeBtn" class="round like" title="Like" disabled>‚ù§Ô∏è</button>
          <button id="skipBtn" class="round skip" title="Skip" disabled>‚è≠Ô∏è</button>
        </div>
      </div>

      <div class="panel">
        <h2 style="margin:0 0 10px 0">Gemeinsame Playlist</h2>
        <div id="playlist" class="playlist"></div>
        <p id="plHint" class="muted" style="margin-top:6px;">
          Hier erscheinen Songs automatisch, sobald ihr beide ‚ù§Ô∏è geklickt habt.
        </p>
      </div>
    </div>
  </div>

  <!-- Zugangscode Script -->
  <script>
    (function(){
      const ACCESS_CODE = '1235';
      const KEY = 'songmatch:ok';
      function unlock(){ document.documentElement.classList.add('gate-ok'); localStorage.setItem(KEY,'1'); }
      if(localStorage.getItem(KEY)==='1'){ unlock(); }
      document.getElementById('gateBtn').onclick = () => {
        const code = document.getElementById('gateCode').value.trim();
        if(code===ACCESS_CODE){ unlock(); } else { alert("Falscher Code"); }
      };
    })();
  </script>

  <!-- App logic -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-app.js";
    import {
      getAuth, onAuthStateChanged, createUserWithEmailAndPassword,
      signInWithEmailAndPassword, updateProfile, signOut
    } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-auth.js";
    import {
      getFirestore, doc, setDoc, getDoc, onSnapshot, serverTimestamp
    } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-firestore.js";

    // --- Firebase ---
    const firebaseConfig = {
      apiKey: "AIzaSyCOYv05V2jXiDYPjc1MlT_WdpgLfW4aJJo",
      authDomain: "songmatch-850c7.firebaseapp.com",
      projectId: "songmatch-850c7",
      storageBucket: "songmatch-850c7.firebasestorage.app",
      messagingSenderId: "139459584433",
      appId: "1:139459584433:web:df99f2c2a15cd6eed41d90"
    };
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db   = getFirestore(app);

    // --- DOM refs ---
    const authTitle = document.getElementById('authTitle');
    const authSwitch = document.getElementById('authSwitch');
    const authSwitchText = document.getElementById('authSwitchText');
    const authMsg = document.getElementById('authMsg');
    const usernameEl = document.getElementById('username');
    const passwordEl = document.getElementById('password');
    const loginBtn = document.getElementById('loginBtn');
    const logoutBtn = document.getElementById('logoutBtn');
    const inviteBtn = document.getElementById('inviteBtn');

    const songArea   = document.getElementById("songArea");
    const likeBtn    = document.getElementById("likeBtn");
    const nopeBtn    = document.getElementById("nopeBtn");
    const undoBtn    = document.getElementById("undoBtn");
    const skipBtn    = document.getElementById("skipBtn");
    const playlistEl = document.getElementById("playlist");
    const plHint     = document.getElementById("plHint");
    const progressInfo = document.getElementById("progressInfo");

    /* ---------- Auth (Username = pseudo-email) ---------- */
    let signUpMode = false;
    function toEmail(u){ return `${u.trim().toLowerCase()}@sm.local`; }
    authSwitch.onclick = () => {
      signUpMode = !signUpMode;
      authTitle.textContent = signUpMode ? 'Account erstellen' : 'Anmelden';
      loginBtn.textContent  = signUpMode ? 'Erstellen & Anmelden' : 'Anmelden';
      authSwitchText.textContent = signUpMode ? 'Schon ein Account?' : 'Noch kein Account?';
      authSwitch.textContent = signUpMode ? 'Anmelden' : 'Account erstellen';
    };
    loginBtn.onclick = async () => {
      const u = usernameEl.value.trim(); const p = passwordEl.value;
      if(!u || !p) { authMsg.textContent = 'Username + Passwort eingeben'; return; }
      authMsg.textContent = '...';
      try {
        if (signUpMode) {
          const cred = await createUserWithEmailAndPassword(auth, toEmail(u), p);
          await updateProfile(cred.user, { displayName: u });
          await setDoc(doc(db, 'users', cred.user.uid), { username: u, createdAt: serverTimestamp() }, { merge: true });
        } else {
          await signInWithEmailAndPassword(auth, toEmail(u), p);
        }
        document.documentElement.classList.add('auth-ok');
        authMsg.textContent = '';
      } catch (e) {
        authMsg.textContent = 'Fehler: ' + (e.code || e.message);
        console.error(e);
      }
    };
    logoutBtn.onclick = async () => {
      await signOut(auth);
      document.documentElement.classList.remove('auth-ok');
      usernameEl.value=''; passwordEl.value='';
    };

    /* ---------- Room handling (Invite-Link) ---------- */
    const qp = new URLSearchParams(location.search);
    let roomId = qp.get('r') || null;

    function roomDoc(id){ return doc(db, "rooms", id); }
    function roomPoolDoc(id){ return doc(db, "rooms", id, "config", "pool"); }
    function roomProgressDoc(id, uid){ return doc(db, "rooms", id, "progress", uid); }
    function roomVoteDoc(id, trackId){ return doc(db, "rooms", id, "votes", trackId); }

    async function resolveRoomAfterLogin(uid){
  if (roomId) {
    const rs = await getDoc(roomDoc(roomId));
    if (rs.exists()) {
      const members = rs.data().members || [];
      if (!members.includes(uid) && members.length < 2) {
        await setDoc(roomDoc(roomId), { members: [...members, uid], updatedAt: serverTimestamp() }, { merge: true });
      }
      return;
    }
  }
  // Neuen Room anlegen
  roomId = Math.random().toString(36).slice(2,10) + Math.random().toString(36).slice(2,10);
  await setDoc(roomDoc(roomId), { members: [uid], createdAt: serverTimestamp() });
  await setDoc(roomPoolDoc(roomId), { ids: [], updatedAt: serverTimestamp() }, { merge: true });

  // URL aktualisieren (fallback auf Redirect, falls replaceState fehlt)
  const url = new URL(window.location.href);
  url.searchParams.set('r', roomId);
  if (window.history && typeof window.history.replaceState === 'function') {
    window.history.replaceState({}, '', url.toString());
  } else {
    window.location.href = url.toString();
  }
}

      // Neuen Room anlegen
      roomId = Math.random().toString(36).slice(2, 10) + Math.random().toString(36).slice(2, 10);
      await setDoc(roomDoc(roomId), {
        members: [uid],
        createdAt: serverTimestamp()
      });
      // Pool-Doc anlegen (leer)
      await setDoc(roomPoolDoc(roomId), { ids: [], updatedAt: serverTimestamp() }, { merge: true });
      // URL anpassen (damit Reloads im gleichen Room bleiben)
      const url = new URL(location.href); url.searchParams.set('r', roomId); history.replaceState({}, '', url);
    }

    inviteBtn.onclick = async ()=>{
      if (!roomId) return;
      const link = `${location.origin}${location.pathname}?r=${roomId}`;
      await navigator.clipboard.writeText(link);
      alert("Invite-Link kopiert:\n" + link + "\nSchick ihn deinem Freund. Nach Login seid ihr beide im gleichen Room.");
    };

    /* ---------- Shared pool + progress ---------- */
    let uid = null, songs = [], index = 0, history = [];
    const listeningSet = new Set();

    onAuthStateChanged(auth, async (user)=>{
      if (!user) { document.documentElement.classList.remove('auth-ok'); return; }
      uid = user.uid;
      document.documentElement.classList.add('auth-ok');

      // Room festlegen/beitreten
      await resolveRoomAfterLogin(uid);

      // Progress laden
      const psnap = await getDoc(roomProgressDoc(roomId, uid));
      index = psnap.exists() ? (psnap.data().index || 0) : 0;

      // Pool sicherstellen & laden
      await ensurePoolHasEnough(200);
      await reloadSongsFromPool();
      setupPlaylistListenersFor(songs);
      renderCurrent();

      // Live-Updates des Pools
      onSnapshot(roomPoolDoc(roomId), (snap)=>{
        const data = snap.exists() ? snap.data() : null;
        const ids = data?.ids || [];
        if (ids.length) {
          songs = ids;
          if (index >= songs.length) index = Math.max(0, songs.length - 1);
          renderCurrent();
        }
      });
    });

    /* ---------- Spotify: Token + Search + Track-Meta f√ºr Preview ---------- */
    async function getToken() {
      const res = await fetch("https://reasorr-github-io.vercel.app/api/token"); // ggf. anpassen
      const data = await res.json();
      return data.access_token;
    }
    async function searchTracks(token, query, limit=50) {
      const offset = Math.floor(Math.random() * 10) * 50;
      const url = `https://api.spotify.com/v1/search?type=track&limit=${limit}&offset=${offset}&market=DE&q=${encodeURIComponent(query)}`;
      const res = await fetch(url, { headers: { "Authorization": "Bearer " + token } });
      if (!res.ok) { console.warn("Search HTTP", res.status, query); return []; }
      const data = await res.json();
      return (data.tracks?.items || []).map(t => t.id).filter(Boolean);
    }
    async function buildBatch() {
      const token = await getToken();
      const queries = [
        'pop year:2022-2025','hip hop year:2022-2025','dance year:2021-2025',
        'rock year:2019-2025','indie year:2019-2025','house year:2020-2025','r&b year:2020-2025'
      ];
      let pool = [];
      for (const q of queries) pool = pool.concat(await searchTracks(token, q, 50));
      const seen = new Set(); const out = [];
      for (const id of pool) if (!seen.has(id)) { seen.add(id); out.push(id); }
      return out;
    }
    async function ensurePoolHasEnough(minCount=200){
      const snap = await getDoc(roomPoolDoc(roomId));
      let ids = snap.exists() ? (snap.data().ids || []) : [];
      if (ids.length >= minCount) return;
      const batch = await buildBatch();
      const set = new Set(ids);
      for (const id of batch) if (!set.has(id)) { set.add(id); ids.push(id); }
      await setDoc(roomPoolDoc(roomId), { ids, updatedAt: serverTimestamp() }, { merge: true });
    }
    async function reloadSongsFromPool(){
      const snap = await getDoc(roomPoolDoc(roomId));
      songs = snap.exists() ? (snap.data().ids || []) : [];
    }

    // Track Meta cache (preview_url, artist, title, cover, link)
    const metaCache = new Map();
    async function getTrackMeta(id){
      if (metaCache.has(id)) return metaCache.get(id);
      const token = await getToken();
      const res = await fetch(`https://api.spotify.com/v1/tracks/${id}?market=DE`, {
        headers: { "Authorization":"Bearer "+token }
      });
      if (!res.ok) { return { id, preview:null, cover:null, title:"", artist:"", link:`https://open.spotify.com/track/${id}` }; }
      const t = await res.json();
      const meta = {
        id,
        preview: t.preview_url || null,
        cover: t.album?.images?.[0]?.url || null,
        title: t.name || "",
        artist: (t.artists||[]).map(a=>a.name).join(", "),
        link: t.external_urls?.spotify || `https://open.spotify.com/track/${id}`
      };
      metaCache.set(id, meta);
      return meta;
    }

    /* ---------- UI helpers ---------- */
    function setButtons(on){ [likeBtn,nopeBtn,undoBtn,skipBtn].forEach(b=>b.disabled=!on); }
    function updateProgressInfo(){ progressInfo.textContent = songs.length ? `Song ${Math.min(index+1,songs.length)} / ${songs.length}` : '‚Äì'; }

    /* ---------- Swipe + Preview Audio ---------- */
    let cardEl=null, badgeLike=null, badgeNope=null, audioEl=null, playing=false;
    let startX=0, startY=0, dx=0, dy=0, dragging=false;

    function mountSwipeCard(meta){
      const { id, preview, cover, title, artist, link } = meta;
      songArea.innerHTML = `
        <div class="swipe-wrap">
          <div class="swipe-card" id="swipeCard">
            <div class="badge like" id="badgeLike">LIKE</div>
            <div class="badge nope" id="badgeNope">NOPE</div>

            <div class="cover">
              ${cover ? `<img src="${cover}" alt="">` : `<div class="muted">kein Cover</div>`}
              <button id="playBtn" class="playbtn">${preview ? '‚ñ∂Ô∏é Abspielen' : '‚ÜóÔ∏é In Spotify √∂ffnen'}</button>
            </div>

            <div class="meta">
              <div>
                <div class="title">${title || '‚Äì'}</div>
                <div class="artist">${artist || ''}</div>
              </div>
              <button class="open" onclick="window.open('${link}','_blank')">Open in Spotify</button>
            </div>
          </div>
        </div>`;
      cardEl = document.getElementById("swipeCard");
      badgeLike = document.getElementById("badgeLike");
      badgeNope = document.getElementById("badgeNope");
      const playBtn = document.getElementById("playBtn");

      // prepare audio
      if (audioEl) { try { audioEl.pause(); } catch{} }
      audioEl = null; playing = false;
      if (preview) {
        audioEl = new Audio(preview);
        audioEl.preload = 'none';
        audioEl.onended = ()=>{ playing=false; playBtn.textContent='‚ñ∂Ô∏é Abspielen'; };
        playBtn.onclick = async (e)=>{ e.stopPropagation();
          try {
            if (!playing) { await audioEl.play(); playing=true; playBtn.textContent='‚è∏Ô∏é Pause'; }
            else { audioEl.pause(); playing=false; playBtn.textContent='‚ñ∂Ô∏é Abspielen'; }
          } catch (err) { alert('Konnte Audio nicht starten (Autoplay blockiert). Tippe nochmal auf Abspielen.'); }
        };
      } else {
        playBtn.onclick = (e)=>{ e.stopPropagation(); window.open(link, '_blank'); };
      }

      // gestures
      const onStart = (x,y)=>{ startX=x; startY=y; dx=0; dy=0; dragging=true; cardEl.style.transition='none'; setButtons(false); };
      const onMove  = (x,y)=>{
        if(!dragging) return;
        dx = x-startX; dy = y-startY;
        const rot = Math.max(-15, Math.min(15, dx/10));
        cardEl.style.transform = `translate(${dx}px, ${dy}px) rotate(${rot}deg)`;
        const s = Math.min(1, Math.abs(dx)/90);
        if (dx>0){ badgeLike.style.opacity = s; badgeNope.style.opacity = 0; }
        else if (dx<0){ badgeNope.style.opacity = s; badgeLike.style.opacity = 0; }
        else { badgeLike.style.opacity=badgeNope.style.opacity=0; }
      };
      const onEnd = ()=>{
        if(!dragging) return;
        dragging=false; cardEl.style.transition='';
        const threshold = 90;
        if (dx > threshold) { if (audioEl) audioEl.pause(); animateDecision('right'); vote('like'); }
        else if (dx < -threshold) { if (audioEl) audioEl.pause(); animateDecision('left'); vote('dislike'); }
        else {
          cardEl.style.transform = `translate(0px, 0px) rotate(0deg)`;
          badgeLike.style.opacity = badgeNope.style.opacity = 0;
          setButtons(true);
        }
      };

      cardEl.addEventListener('touchstart', e=>{ const t=e.touches[0]; onStart(t.clientX,t.clientY); }, {passive:true});
      cardEl.addEventListener('touchmove',  e=>{ const t=e.touches[0]; onMove(t.clientX,t.clientY); }, {passive:true});
      cardEl.addEventListener('touchend', onEnd);
      cardEl.addEventListener('mousedown', e=>{ onStart(e.clientX,e.clientY); });
      window.addEventListener('mousemove', e=>{ onMove(e.clientX,e.clientY); });
      window.addEventListener('mouseup', onEnd);
    }

    function animateDecision(direction){
      if(!cardEl) return;
      const offX = direction==='right' ? window.innerWidth : -window.innerWidth;
      cardEl.style.transition = 'transform .25s ease, opacity .25s ease';
      cardEl.style.transform  = `translate(${offX}px, 0) rotate(${direction==='right'?15:-15}deg)`;
      cardEl.style.opacity = '0'; badgeLike && (badgeLike.style.opacity=0); badgeNope && (badgeNope.style.opacity=0);
    }

    /* ---------- Render (mit robustem Nachf√ºllen) ---------- */
    async function renderCurrent(){
      if (!songs.length){
        songArea.textContent = "üé∂ Lade Songs ‚Ä¶";
        await ensurePoolHasEnough(200); await reloadSongsFromPool();
      }
      if (!songs.length){ songArea.textContent = "üòï Konnte keine Songs laden."; return; }

      if (index >= songs.length) {
        await ensurePoolHasEnough(200); await reloadSongsFromPool();
        if (index >= songs.length) index = Math.max(0, songs.length - 1);
      }

      const id = songs[index];
      const meta = await getTrackMeta(id);
      mountSwipeCard(meta);
      updateProgressInfo();
      setButtons(true);

      if (songs.length - index - 1 < 15) { ensurePoolHasEnough(200); } // fire & forget
    }

    /* ---------- Voting + Undo/Skip ---------- */
    async function vote(val){
      if(!uid || index >= songs.length) return;
      const id = songs[index];
      history.push({ id, val });
      await setDoc(roomVoteDoc(roomId, id), { [uid]: val, updatedAt: serverTimestamp() }, { merge: true });
      index = Math.min(index + 1, songs.length);
      await setDoc(roomProgressDoc(roomId, uid), { index, updatedAt: serverTimestamp() }, { merge: true });
      setTimeout(renderCurrent, 150);
      if (navigator.vibrate) { navigator.vibrate(10); }
    }
    likeBtn.onclick = ()=>{ animateDecision('right'); vote('like'); };
    nopeBtn.onclick = ()=>{ animateDecision('left');  vote('dislike'); };
    skipBtn.onclick = ()=>{ index = Math.min(index + 1, songs.length); setDoc(roomProgressDoc(roomId, uid), { index, updatedAt: serverTimestamp() }, { merge:true }); renderCurrent(); };
    undoBtn.onclick = async ()=>{
      const last = history.pop(); if(!last) return;
      index = Math.max(index - 1, 0);
      await setDoc(roomProgressDoc(roomId, uid), { index, updatedAt: serverTimestamp() }, { merge: true });
      renderCurrent();
    };
    window.addEventListener('keydown', e=>{
      if(likeBtn.disabled) return;
      if(e.key==='ArrowRight') likeBtn.click();
      if(e.key==='ArrowLeft')  nopeBtn.click();
      if(e.key===' ') { e.preventDefault(); skipBtn.click(); }
    });

    /* ---------- Gemeinsame Playlist (2 Likes) ---------- */
    function setupPlaylistListenersFor(ids){
      ids.forEach(id=>{
        if (listeningSet.has(id)) return;
        listeningSet.add(id);
        onSnapshot(roomVoteDoc(roomId, id), snap => {
          if(!snap.exists()) return;
          const data = snap.data();
          const vals = Object.values(data).filter(v => v==="like"||v==="dislike");
          if(vals.length >= 2 && vals.every(v => v==="like")){
            const elId = "pl-"+id;
            if(!document.getElementById(elId)){
              const iframe = document.createElement("iframe");
              iframe.id = elId;
              iframe.className = "embed-small";
              iframe.src = `https://open.spotify.com/embed/track/${id}`;
              playlistEl.appendChild(iframe);
              if (plHint) plHint.style.display = "none";
            }
          }
        });
      });
    }
  </script>
</body>
</html>
