<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>SongMatch</title>
  <style>
    :root { color-scheme: dark; }
    * { box-sizing: border-box; }
    body { font-family: system-ui, Arial, sans-serif; background:#0b0f14; color:#fff; margin:0; }
    .gate { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:#000; z-index:9999; }
    .gate-card { background:#121822; padding:24px; border-radius:14px; text-align:center; width:min(420px,92vw); }
    .gate-card input, .gate-card button { padding:12px 14px; margin:6px 0; border-radius:10px; border:none; width:100%; }
    .gate-card button { background:#7aa2ff; color:#fff; cursor:pointer; font-weight:700; }
    html:not(.gate-ok) .app { display:none; }
    html.gate-ok .gate { display:none; }

    .wrap { max-width:820px; margin:0 auto; padding:16px; }
    .card { background:#121822; margin:20px 0; padding:20px; border-radius:14px; }
    .center { text-align:center; }
    .muted { opacity:.75; font-size:14px; }

    /* Swipe Card */
    .swipe-wrap { position:relative; height:420px; display:flex; align-items:center; justify-content:center; touch-action:pan-y; }
    .swipe-card { position:absolute; width:min(360px,92vw); height:380px; border-radius:16px; overflow:hidden; box-shadow:0 10px 30px rgba(0,0,0,.35); background:#0f1520; transition:transform .25s ease, opacity .25s ease; }
    .swipe-card iframe { width:100%; height:100%; border:0; display:block; }
    .badge { position:absolute; top:12px; padding:6px 10px; border-radius:8px; font-weight:800; letter-spacing:.5px; opacity:0; transition:opacity .12s ease; }
    .badge.like { left:12px; background:rgba(46,204,113,.9); }
    .badge.dislike { right:12px; background:rgba(231,76,60,.9); }

    .row { display:flex; gap:12px; align-items:center; justify-content:center; flex-wrap:wrap; margin-top:12px; }
    button.vote { font-size:18px; padding:12px 22px; border:none; border-radius:12px; cursor:pointer; font-weight:800; }
    .like-btn { background:#2ecc71; }
    .dislike-btn { background:#e74c3c; }
    .vote:disabled { opacity:.6; cursor:not-allowed; }

    .playlist { display:grid; gap:10px; }
    iframe.embed-small { width:100%; height:80px; border-radius:10px; }
  </style>
</head>
<body>
  <!-- Zugangscode -->
  <div class="gate">
    <div class="gate-card">
      <h1>Zugang</h1>
      <p>Bitte Code eingeben:</p>
      <input id="gateCode" type="password" placeholder="Code (z. B. 1235)" />
      <button id="gateBtn">Weiter</button>
    </div>
  </div>

  <!-- App -->
  <div class="app">
    <div class="wrap">
      <div class="card center">
        <h2>N√§chster Song</h2>
        <div id="songArea" class="muted">
          l√§dt Songs ‚Ä¶
        </div>
        <div class="row">
          <button id="likeBtn" class="vote like-btn" disabled>‚ù§Ô∏è Like</button>
          <button id="dislikeBtn" class="vote dislike-btn" disabled>‚úñÔ∏è Dislike</button>
        </div>
      </div>

      <div class="card">
        <h2>Gemeinsame Playlist</h2>
        <div id="playlist" class="playlist"></div>
        <p id="plHint" class="muted" style="margin-top:6px;">
          Hier erscheinen Songs automatisch, sobald ihr beide ‚ù§Ô∏è geklickt habt.
        </p>
      </div>
    </div>
  </div>

  <!-- Zugangscode Script -->
  <script>
    (function(){
      const ACCESS_CODE = '1235';
      const KEY = 'songmatch:ok';
      function unlock(){ document.documentElement.classList.add('gate-ok'); localStorage.setItem(KEY,'1'); }
      if(localStorage.getItem(KEY)==='1'){ unlock(); }
      document.getElementById('gateBtn').onclick = () => {
        const code = document.getElementById('gateCode').value.trim();
        if(code===ACCESS_CODE){ unlock(); } else { alert("Falscher Code"); }
      };
    })();
  </script>

  <!-- Firebase + Spotify Logik -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-auth.js";
    import {
      getFirestore, doc, setDoc, getDoc, onSnapshot, serverTimestamp
    } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-firestore.js";

    // üîë Firebase Config
    const firebaseConfig = {
      apiKey: "AIzaSyCOYv05V2jXiDYPjc1MlT_WdpgLfW4aJJo",
      authDomain: "songmatch-850c7.firebaseapp.com",
      projectId: "songmatch-850c7",
      storageBucket: "songmatch-850c7.firebasestorage.app",
      messagingSenderId: "139459584433",
      appId: "1:139459584433:web:df99f2c2a15cd6eed41d90"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db   = getFirestore(app);
    signInAnonymously(auth).catch(console.error);

    // DOM
    const songArea   = document.getElementById("songArea");
    const likeBtn    = document.getElementById("likeBtn");
    const dislikeBtn = document.getElementById("dislikeBtn");
    const playlistEl = document.getElementById("playlist");
    const plHint     = document.getElementById("plHint");

    // State
    let uid = null;
    let songs = [];        // gemeinsamer Pool (Queue) aus Firestore
    let index = 0;         // pers√∂nlicher Fortschritt (persistiert in Firestore)
    let listened = new Set(); // f√ºr Playlist-Listener (Duplikate vermeiden)

    // ---- Spotify Token vom Backend ----
    async function getToken() {
      const res = await fetch("https://reasorr-github-io.vercel.app/api/token"); // ggf. URL anpassen
      const data = await res.json();
      return data.access_token;
    }

    // ---- Nur Search nutzen (client-credentials-safe) ----
    async function searchTracks(token, query, limit=50) {
      const offset = Math.floor(Math.random() * 10) * 50; // 0..450
      const url = `https://api.spotify.com/v1/search?type=track&limit=${limit}&offset=${offset}&market=DE&q=${encodeURIComponent(query)}`;
      const res = await fetch(url, { headers: { "Authorization": "Bearer " + token } });
      if (!res.ok) { console.warn("Search HTTP", res.status, query); return []; }
      const data = await res.json();
      return (data.tracks?.items || []).map(t => t.id).filter(Boolean);
    }

    async function buildBatch() {
      const token = await getToken();
      const queries = [
        'pop year:2022-2025','hip hop year:2022-2025','dance year:2021-2025',
        'rock year:2019-2025','indie year:2019-2025','house year:2020-2025','r&b year:2020-2025'
      ];
      let pool = [];
      for (const q of queries) pool = pool.concat(await searchTracks(token, q, 50));
      // dedupe, Reihenfolge beibehalten
      const seen = new Set(); const out = [];
      for (const id of pool) if (!seen.has(id)) { seen.add(id); out.push(id); }
      return out;
    }

    // ---- Gemeinsamer Pool in Firestore ----
    const poolRef = doc(db, "config", "pool");       // { ids: string[] }
    let initialPoolFetched = false;

    onSnapshot(poolRef, (snap) => {
      const data = snap.exists() ? snap.data() : null;
      const ids = data?.ids || [];
      if (ids.length) {
        const hadNoneBefore = songs.length === 0;
        songs = ids;
        if (index >= songs.length) index = Math.max(0, songs.length - 1);
        renderCurrent();
        if (hadNoneBefore) setupPlaylistListenerIncremental(); // erst starten wenn es Songs gibt
      }
      initialPoolFetched = true;
    });

    async function ensurePoolHasEnough(minCount = 200) {
      const snap = await getDoc(poolRef);
      let ids = snap.exists() ? (snap.data().ids || []) : [];
      if (ids.length >= minCount) return;

      const batch = await buildBatch();
      // ans Ende anh√§ngen, Duplikate vermeiden
      const set = new Set(ids);
      for (const id of batch) if (!set.has(id)) { set.add(id); ids.push(id); }

      await setDoc(poolRef, { ids, updatedAt: serverTimestamp() }, { merge: true });
    }

    // ---- Fortschritt pro User persistieren ----
    function progressRefFor(uid){ return doc(db, "progress", uid); }

    async function loadProgress() {
      const ref = progressRefFor(uid);
      const snap = await getDoc(ref);
      const saved = snap.exists() ? (snap.data().index ?? 0) : (parseInt(localStorage.getItem("sm_idx_"+uid)||"0",10) || 0);
      index = Number.isFinite(saved) ? saved : 0;
    }

    async function saveProgress() {
      if (!uid) return;
      localStorage.setItem("sm_idx_"+uid, String(index));
      await setDoc(progressRefFor(uid), { index, updatedAt: serverTimestamp() }, { merge: true });
    }

    // ---- Swipe UI ----
    let startX=0, startY=0, dx=0, dy=0, dragging=false;
    let cardEl=null, badgeLike=null, badgeNope=null;

    function mountSwipeCard(trackId){
      songArea.innerHTML = `
        <div class="swipe-wrap">
          <div class="swipe-card" id="swipeCard">
            <div class="badge like" id="badgeLike">LIKE</div>
            <div class="badge dislike" id="badgeNope">NOPE</div>
            <iframe src="https://open.spotify.com/embed/track/${trackId}"
              allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"></iframe>
          </div>
        </div>
      `;
      cardEl = document.getElementById("swipeCard");
      badgeLike = document.getElementById("badgeLike");
      badgeNope = document.getElementById("badgeNope");

      const onStart = (x,y)=>{ startX=x; startY=y; dx=0; dy=0; dragging=true; cardEl.style.transition='none'; };
      const onMove  = (x,y)=>{
        if(!dragging) return;
        dx = x-startX; dy = y-startY;
        const rot = Math.max(-15, Math.min(15, dx/10));
        cardEl.style.transform = `translate(${dx}px, ${dy}px) rotate(${rot}deg)`;
        const s = Math.min(1, Math.abs(dx)/90);
        if (dx>0){ badgeLike.style.opacity = s; badgeNope.style.opacity = 0; }
        else if (dx<0){ badgeNope.style.opacity = s; badgeLike.style.opacity = 0; }
        else { badgeLike.style.opacity=badgeNope.style.opacity=0; }
      };
      const onEnd = ()=>{
        if(!dragging) return;
        dragging=false;
        cardEl.style.transition='';
        const threshold = 90;
        if (dx > threshold) {
          animateDecision('right'); vote('like');
        } else if (dx < -threshold) {
          animateDecision('left');  vote('dislike');
        } else {
          // snap back
          cardEl.style.transform = `translate(0px, 0px) rotate(0deg)`;
          badgeLike.style.opacity = badgeNope.style.opacity = 0;
          setVotingEnabled(true);
        }
      };

      // touch
      cardEl.addEventListener('touchstart', e=>{
        setVotingEnabled(false);
        const t=e.touches[0]; onStart(t.clientX, t.clientY);
      }, {passive:true});
      cardEl.addEventListener('touchmove', e=>{
        const t=e.touches[0]; onMove(t.clientX, t.clientY);
      }, {passive:true});
      cardEl.addEventListener('touchend', onEnd);
      // mouse (optional desktop)
      cardEl.addEventListener('mousedown', e=>{ setVotingEnabled(false); onStart(e.clientX,e.clientY); });
      window.addEventListener('mousemove', e=>{ if(dragging) onMove(e.clientX,e.clientY); });
      window.addEventListener('mouseup', onEnd);
    }

    function animateDecision(direction){
      if(!cardEl) return;
      const offX = direction==='right' ? window.innerWidth : -window.innerWidth;
      cardEl.style.transition = 'transform .25s ease, opacity .25s ease';
      cardEl.style.transform  = `translate(${offX}px, 0) rotate(${direction==='right'?15:-15}deg)`;
      cardEl.style.opacity = '0';
      badgeLike && (badgeLike.style.opacity=0);
      badgeNope && (badgeNope.style.opacity=0);
    }

    // Buttons & Keyboard
    function setVotingEnabled(on){ likeBtn.disabled=!on; dislikeBtn.disabled=!on; }
    likeBtn.onclick    = ()=>{ animateDecision('right'); vote('like'); };
    dislikeBtn.onclick = ()=>{ animateDecision('left');  vote('dislike'); };
    window.addEventListener('keydown', e=>{
      if(likeBtn.disabled) return;
      if(e.key==='ArrowRight') likeBtn.click();
      if(e.key==='ArrowLeft')  dislikeBtn.click();
    });

    // ---- Render & Vote ----
    function renderCurrent(){
      if (!songs.length){
        songArea.innerHTML = "<p>üé∂ Lade Songs ‚Ä¶</p>";
        return;
      }
      const id = songs[index] || songs[songs.length-1];
      mountSwipeCard(id);
      setVotingEnabled(true);
      // Pool rechtzeitig auff√ºllen
      const remaining = songs.length - index - 1;
      if (remaining < 15) ensurePoolHasEnough(200);
    }

    async function vote(val){
      if(!uid){ alert("Noch nicht verbunden, bitte kurz warten!"); return; }
      setVotingEnabled(false);
      const id = songs[index];
      // Votes speichern
      await setDoc(doc(db, "votes", id), { [uid]: val, updatedAt: serverTimestamp() }, { merge: true });
      // Fortschritt erh√∂hen + speichern
      index = Math.min(index + 1, songs.length);
      await saveProgress();
      // N√§chster Track
      setTimeout(()=>renderCurrent(), 150);
    }

    // ---- Gemeinsame Playlist-Listener (inkrementell anh√§ngen) ----
    function setupPlaylistListenerIncremental(){
      for (const id of songs){
        if (listened.has(id)) continue;
        listened.add(id);
        const ref = doc(db, "votes", id);
        onSnapshot(ref, snap => {
          if(!snap.exists()) return;
          const data = snap.data();
          const vals = Object.values(data).filter(v => v==="like"||v==="dislike");
          if(vals.length >= 2 && vals.every(v => v==="like")){
            if(!document.getElementById("pl-"+id)){
              const iframe = document.createElement("iframe");
              iframe.id = "pl-"+id;
              iframe.className = "embed-small";
              iframe.src = `https://open.spotify.com/embed/track/${id}`;
              playlistEl.appendChild(iframe);
              if (plHint) plHint.style.display = "none";
            }
          }
        });
      }
    }

    // ---- Start-Sequenz ----
    onAuthStateChanged(auth, async (user)=>{
      if (!user) return;
      uid = user.uid;

      // 1) Pool bereitstellen (falls leer)
      await ensurePoolHasEnough(200);

      // 2) Fortschritt laden
      await loadProgress();

      // 3) Falls Pool-Snapshot noch nicht da ist, einmalig laden
      if (!initialPoolFetched) {
        const snap = await getDoc(poolRef);
        songs = snap.exists() ? (snap.data().ids || []) : [];
      }

      // 4) Render
      renderCurrent();
    });
  </script>
</body>
</html>
