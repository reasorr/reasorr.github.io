<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SongMatch</title>
  <style>
    :root { color-scheme: dark; }
    body { font-family: system-ui, Arial, sans-serif; background:#0b0f14; color:#fff; margin:0; }
    .gate { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:#000; z-index:9999; }
    .gate-card { background:#121822; padding:24px; border-radius:12px; text-align:center; width:min(400px, 92vw); }
    .gate-card input, .gate-card button { padding:12px 14px; margin:6px 0; border-radius:8px; border:none; width:100%; box-sizing:border-box; }
    .gate-card button { background:#7aa2ff; color:white; cursor:pointer; font-weight:600; }
    html:not(.gate-ok) .app { display:none; }
    html.gate-ok .gate { display:none; }

    .wrap { max-width:820px; margin:0 auto; padding:16px; }
    .card { background:#121822; margin:20px 0; padding:20px; border-radius:12px; }
    .center { text-align:center; }
    .row { display:flex; gap:12px; align-items:center; justify-content:center; flex-wrap:wrap; }
    button.vote { font-size:18px; padding:12px 22px; border:none; border-radius:10px; cursor:pointer; font-weight:700; }
    .like { background:#2ecc71; }
    .dislike { background:#e74c3c; }
    .vote:disabled { opacity:.6; cursor:not-allowed; }
    iframe { border:none; border-radius:10px; display:block; margin:0 auto; }
    .playlist { display:grid; gap:10px; }
    .muted { opacity:.75; font-size:14px; }
  </style>
</head>
<body>
  <!-- Zugangscode -->
  <div class="gate">
    <div class="gate-card">
      <h1>Zugang</h1>
      <p>Bitte Code eingeben:</p>
      <input id="gateCode" type="password" placeholder="Code (z. B. 1235)" />
      <button id="gateBtn">Weiter</button>
    </div>
  </div>

  <!-- App -->
  <div class="app">
    <div class="wrap">
      <div class="card center">
        <h2>N√§chster Song</h2>
        <div id="songArea" class="muted">l√§dt Songs ‚Ä¶</div>
        <div class="row" style="margin-top:12px;">
          <button id="likeBtn" class="vote like" disabled>‚ù§Ô∏è Like</button>
          <button id="dislikeBtn" class="vote dislike" disabled>‚úñÔ∏è Dislike</button>
        </div>
      </div>

      <div class="card">
        <h2>Gemeinsame Playlist</h2>
        <div id="playlist" class="playlist"></div>
        <p id="plHint" class="muted" style="margin-top:6px;">
          Hier erscheinen Songs automatisch, sobald ihr beide ‚ù§Ô∏è geklickt habt.
        </p>
      </div>
    </div>
  </div>

  <!-- Zugangscode Script -->
  <script>
    (function(){
      const ACCESS_CODE = '1235';
      const KEY = 'songmatch:ok';
      function unlock(){ document.documentElement.classList.add('gate-ok'); localStorage.setItem(KEY,'1'); }
      if(localStorage.getItem(KEY)==='1'){ unlock(); }
      document.getElementById('gateBtn').onclick = () => {
        const code = document.getElementById('gateCode').value.trim();
        if(code===ACCESS_CODE){ unlock(); } else { alert("Falscher Code"); }
      };
    })();
  </script>

  <!-- Firebase + Spotify Logik -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-app.js";
    import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.12.3/firebase-auth.js";
    import { getFirestore, doc, setDoc, onSnapshot, serverTimestamp }
      from "https://www.gstatic.com/firebasejs/10.12.3/firebase-firestore.js";

    // üîë Firebase Config (dein Projekt)
    const firebaseConfig = {
      apiKey: "AIzaSyCOYv05V2jXiDYPjc1MlT_WdpgLfW4aJJo",
      authDomain: "songmatch-850c7.firebaseapp.com",
      projectId: "songmatch-850c7",
      storageBucket: "songmatch-850c7.firebasestorage.app",
      messagingSenderId: "139459584433",
      appId: "1:139459584433:web:df99f2c2a15cd6eed41d90"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    signInAnonymously(auth).catch(console.error);

    let uid = null;
    auth.onAuthStateChanged(user => { if (user) uid = user.uid; });

    // DOM
    const songArea   = document.getElementById("songArea");
    const likeBtn    = document.getElementById("likeBtn");
    const dislikeBtn = document.getElementById("dislikeBtn");
    const playlistEl = document.getElementById("playlist");
    const plHint     = document.getElementById("plHint");

    // State
    let songs = [];        // queue of track IDs
    let index = 0;
    const likedSeeds = []; // keep last few liked tracks (optional future use)

    // UI helpers
    function setVotingEnabled(on) {
      likeBtn.disabled = !on;
      dislikeBtn.disabled = !on;
    }

    async function showSong(i){
      if(i >= songs.length){
        songArea.innerHTML = "<p>üé∂ Lade neue Songs ‚Ä¶</p>";
        await topUpSongs();               // fetch more
        if (i >= songs.length) {
          songArea.innerHTML = "<p>üòï Keine Songs gefunden. Bitte neu laden.</p>";
          return;
        }
      }
      const id = songs[i];
      songArea.innerHTML = `<iframe src="https://open.spotify.com/embed/track/${id}" width="320" height="380" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"></iframe>`;
      setVotingEnabled(true);
    }

    // Vote speichern + lokal weiterschalten
    async function vote(val){
      if(!uid){ alert("Noch nicht verbunden, bitte kurz warten!"); return; }
      setVotingEnabled(false);
      const id = songs[index];
      const ref = doc(db, "votes", id);
      await setDoc(ref, { [uid]: val, updatedAt: serverTimestamp() }, { merge: true });
      if (val === "like") {
        likedSeeds.push(id);
        if (likedSeeds.length > 5) likedSeeds.splice(0, likedSeeds.length - 5);
      }
      index++;
      showSong(index);
    }
    likeBtn.onclick = () => vote("like");
    dislikeBtn.onclick = () => vote("dislike");

    // Gemeinsame Playlist-Listener
    function setupPlaylistListener(ids){
      ids.forEach(id => {
        const ref = doc(db, "votes", id);
        onSnapshot(ref, snap => {
          if(!snap.exists()) return;
          const data = snap.data();
          const vals = Object.values(data).filter(v => v==="like" || v==="dislike");
          if(vals.length >= 2 && vals.every(v => v==="like")){
            if(!document.getElementById("pl-"+id)){
              const iframe = document.createElement("iframe");
              iframe.id   = "pl-"+id;
              iframe.width = "100%";
              iframe.height = "80";
              iframe.src = `https://open.spotify.com/embed/track/${id}`;
              playlistEl.appendChild(iframe);
              if (plHint) plHint.style.display = "none";
            }
          }
        });
      });
    }

    // üîë Spotify-Token √ºber dein Vercel-Backend holen (URL ggf. anpassen)
    async function getToken() {
      const res = await fetch("https://reasorr-github-io.vercel.app/api/token");
      const data = await res.json();
      return data.access_token;
    }

    // ---- Spotify SEARCH loader (works with client-credentials) ----
    async function searchTracks(token, query, limit=50) {
      // randomize offset a bit to avoid always the same results
      const offset = Math.floor(Math.random() * 10) * 50; // 0..450
      const url = `https://api.spotify.com/v1/search?type=track&limit=${limit}&offset=${offset}&market=DE&q=${encodeURIComponent(query)}`;
      const res = await fetch(url, { headers: { "Authorization": "Bearer " + token } });
      if (!res.ok) { console.warn("Search HTTP", res.status, query); return []; }
      const data = await res.json();
      return (data.tracks?.items || []).map(t => t.id).filter(Boolean);
    }

    // Queue auff√ºllen (nur Search; no editorial/algorithmic/recommendations)
    async function topUpSongs(){
      const token = await getToken();

      // Broad queries (use simple words + year filter = supported)
      const queries = [
        'pop year:2022-2025',
        'hip hop year:2022-2025',
        'dance year:2021-2025',
        'rock year:2019-2025',
        'indie year:2019-2025',
        'house year:2020-2025',
        'r&b year:2020-2025'
      ];

      let pool = [];
      for (const q of queries) {
        const ids = await searchTracks(token, q, 50);
        pool = pool.concat(ids);
      }

      // Deduplicate + shuffle
      const set = new Set(songs);
      const fresh = [];
      for (const id of pool) if (!set.has(id)) { set.add(id); fresh.push(id); }
      for (let i = fresh.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [fresh[i], fresh[j]] = [fresh[j], fresh[i]];
      }

      if (fresh.length) {
        songs = songs.concat(fresh);
        setupPlaylistListener(fresh);
      }
    }

    // Start
    (async () => {
      await topUpSongs();   // initiales F√ºllen
      index = 0;
      showSong(index);
    })();
  </script>
</body>
</html>
